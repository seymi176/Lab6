---
title: "Writing fast R code"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Writing fast R code}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style>
body {
text-align: justify}
</style>

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

This package is created to study the effects of algorithms with different computational
complexity and investigate how to speedup R code.The package aims to solve the NP-hard knapsack problem by defining three functions, each utilizing different approach and method. The knapsack problem is a discrete optimization problem where we have a knapsack that can take a
limited weight W and we want to fill this knapsack with a number of items *i* = 1, ..., n, each with a weight w~i~ and a value v~i~. The goal is to find the knapsack with the largest value of the elements added to the knapsack.


### 1.1.2 Brute force search

As shown below, it takes around *1.7* seconds for the function *"brute_force_knapsack"* to find the solution for n = 16 objects.
```{r setup}
library(Lab6)
system.time(brute_force_knapsack(x = knapsack_objects[1:16,], W = 3500), gcFirst = T)
```


### 1.1.3 Dynamic programming

As expected, the dynamic algorithm has better performance than previous one, and it takes around *10* seconds for the  *"knapsack_dynamic"* to find the solution for n = 500 objects.

```{r}
system.time(knapsack_dynamic(x = knapsack_objects[1:500,], W = 3500), gcFirst = T)
```

### 1.1.4 Greedy heuristic

In terms of calculation time, the greedy algorithm has the best performance among others.It takes around *3* seconds for the  *"greedy_knapsack"* to find the solution for n = 1000000 objects.

```{r}
system.time(greedy_knapsack(x = knapsack_objects[1:1000000,], W = 3500), gcFirst = T)
```

